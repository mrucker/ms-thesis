%seed == 1
%Start of Algorithm5 
%Completed IRL iteration, i=2, t=0.032359
%Completed IRL iteration, i=3, t=0.010066
%Completed IRL iteration, i=4, t=0.009096
%FINISHED IRL,i=3, t=0.010066 
%exp_time=0.007863 
%krn_time=0.000000 
%svm_time=0.003262 
%mdp_time=0.000446 
%mix_time=0.602062 

function [bestPath,bestFeatures] = featureExpectation(firstLocation, targetData, actions, reward, gamma)

    pruneCount  = 0;
    visitCount  = 0;
    finalDepth  = size(targetData,1)-1;
    actionCount = size(actions,2);
    
    bestPath     = horzcat(zeros(2,finalDepth),firstLocation);
    bestFeatures = zeros(6,1);    
    
    visitTime   = 0;
    makeTime    = 0;
    growTime    = 0;
    pruneTime   = 0;
    featureTime = 0;
    reshapeTime = 0;

    first = struct('depth',0, 'locations',[], 'features',[]);
    
    first.depth            = 0;
    first.locations        = firstLocation;
    first.features         = features(first.locations, targetData{first.depth+1});
    
    stack = {first};
    
    if first.depth == finalDepth
        bestFeatures = first.features;
        bestPath     = first.locations;
        return;
    end
    
    while ~isempty(stack)
    
        myTic();
            visitCount = visitCount + 1;
            current = stack{end};
            stack(end) = [];
        visitTime = visitTime + myToc();
        
        myTic();
            nextHistory        = current.locations(:,1:3);
            nextLocations      = current.locations(:,1) + actions; 
            nextFeatures       = currentFfeatures(horzcat(nextLocations,nextHistory),targetData{current.depth+2});
            nextParentFeatures = current.parentFeatures + gamma^current.depth * current.features;
        featureTime = featureTime + myToc();
        
        for a = 1:actionCount
            
            myTic();
                thisNextDepth     = current.depth+1;            
                thisNextFeatures  = vertcat(nextFeatures (a,1), nextFeatures(end-4:end));
                thisNextParents   = nextParentFeatures;
            reshapeTime = reshapeTime + myToc();
            
            myTic();
                if prunable(bestFeatures, thisNextParents, thisNextFeatures, thisNextDepth, finalDepth, gamma, reward)
                    pruneCount = pruneCount + actionCount^(thisNextDepth-finalDepth);
                    continue;
                end
            pruneTime = pruneTime + myToc();
            
            %if we didn't prune above, and we're on the leaf node now, we know this path is better than the current best
            if thisNextDepth == finalDepth
                bestFeatures = nextParentFeatures + gamma^next.depth * next.features;
                bestPath     = next.locations;
                continue;
            end
            
            myTic();
                thisNextLocations = horzcat(nextLocations(:,a), current.locations);
                next = struct('depth',thisNextDepth, 'locations',thisNextLocations, 'features',thisNextFeatures,  'parentFeatures',thisNextParents);
            makeTime = makeTime + myToc();
            
            myTic();
                stack{end+1} = next;
            growTime = growTime + myToc();
        end        
    end
end

function myTic()
    %tic
end

function t = myToc()
    t = 0;    
    %t = toc;   
end

function p = prunable(bestFeatures, parentFeatures, currentFeatures, currentDepth, finalDepth, gamma, reward)
        
    % R(best)-R(parents)-\sum_{i=depth+1}_{finalDepth}gamma^i >= gamma^depth*R(current)    
    p = ((bestFeatures - parentFeatures)' * reward - ((1-gamma^finalDepth)/(1-gamma) - (1-gamma^currentDepth)/(1-gamma))) > gamma^currentDepth*currentFeatures'*reward;
        
end