function expectedFeatures = featureExpectation(featureExpert, firstLocation, targetData, actions, reward, gamma)

    pruneCount   = 0;
    visitCount   = 0;
    finalDepth   = size(targetData,1)-1;
    bestFeatures = featureExpert;
    
    visitTime = 0;
    makeTime  = 0;
    growTime  = 0;
    pruneTime = 0;
    
    
    %first = struct('depth',0, 'locations',[], 'features',[],  'parentFeatures',[]);
    first = zeros(21,1);
    
    first(1)       = 0;
    first(2:9,1)   = reshape(firstLocation,[],1);
    first(10:15,1) = features(first(2:9), targetData{first(1)+1});
    first(16:21,1) = [0,0,0,0,0,0]'; %[d1,d2,d3,d4,touched,age]
    
    stack = first;
    
    while ~isempty(stack)
    
        tic
        visitCount = visitCount + 1;
        current = stack(:,end);
        stack(:, end) = [];
        visitTime = visitTime + toc;

        for a = actions
            
            tic            
            
            next = zeros(21,1);
            
            next(1)     = current(1)+1;
            next(3:9)   = current(2:8);
            next(2)     = current(2).locations(:,1) + a;            
            next(10:15)           = features(next.locations, targetData{next.depth+1});
            next(16:21)     = current.parentFeatures + gamma^current.depth * current.features;
            makeTime = makeTime + toc;
            
            tic
            if prunable(bestFeatures, next.parentFeatures, next.features, next.depth, finalDepth, gamma, reward)
                pruneCount = pruneCount + 400^(next.depth-finalDepth);
                continue;
            end
            pruneTime = pruneTime + toc;
            
            %if we didn't prune above, and we're on the leaf node now, we know this path is better than the current best
            if next.depth == finalDepth
                bestFeatures = next.parentFeatures + gamma^next.depth * next.features;
                continue;
            end
            
            tic
            stack{end+1} = next;
            growTime = growTime + toc;
        end        
    end
    
    expectedFeatures = bestFeatures;
end

function p = prunable(bestFeatures, parentFeatures, currentFeatures, currentDepth, finalDepth, gamma, reward)
    
    % There may be an incorrect calculation here regarding the partial geometric series terminating at finalDepth
    % R(best)-R(parents)-\sum_{i=depth+1}_{finalDepth}gamma^i >= gamma^depth*R(current)    
    p = ((bestFeatures - parentFeatures)' * reward - ((1-gamma^finalDepth)/(1-gamma) - (1-gamma^currentDepth)/(1-gamma))) > gamma^currentDepth*currentFeatures'*reward;
        
end